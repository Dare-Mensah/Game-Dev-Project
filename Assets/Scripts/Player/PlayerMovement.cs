using System.Collections; // use of statement ensures the system.collection is imported to be used for collections like arrays
using System.Collections.Generic;
using UnityEngine;

public class PlayerMovement : MonoBehaviour
{// pausemenu class that inherits from the monobehaviour class which thus enables for it to be assigned to the gameobjects and make use of unity features


    private Animator animator; //private reference is made to the animator component that is made use of in manipulating animations contingent on player movement

    public AudioSource jumpSound; // public reference is made to the audiosource component this will enable for an appropriate sound to be played when players jump
    public AudioSource moveSound; // public reference is made to the audiosource component this will enable for an appropriate sound to be played when players move around

    [Header("Movement Refernces")]
    public float movespeed; //public floar defines the players movement speed

    public float groundedDrag; //public float defines the drag players will be subjected when the player in on ground level which will impact how fast they can move when input is absent

    public float jumpForce; //public variable to define force generated by a player jumping
    public float jumpCooldown; // public variable to define the cooldown period between player jumps to prevent excessive jumping
    public float airMultiplier; // public variable to define the extent to which players control jump distance between them and ground
    bool readyToJump; //bool variable runs check to see if the player is ready to jump 

    [Header("KeyBinds")]
    public KeyCode jumpKey = KeyCode.Space; //this is the keycode for jump input which is set to the spacebar
    

    [Header("Ground Check")]
    public float playerHeight; //public var to defien the player height which is utilised as per determining whether a player is grounded on the floor
    public LayerMask whatIsGround; //public variable defines the layers that make up ground level environment
    public bool grounded; // public bool checks whether the player is set to ground level

    public Transform orientation; // current player orientation

    [Header("Sprite")]
    public SpriteRenderer sR; //public referencing to the sprite render component thus enabling for control over player sprite

    float horizontalInput; //private float stores the horizontal input value
    float verticalInput; //private float stores the vertical input value

    Vector3 moveDir; //the use of Vector3 is deployed to store the players desired direction of movement

    Rigidbody rB;
// private reference to the rigidbody component that is responsible for dictating the players physical movements
    


    // Start is called before the first frame update
    void Start()
    {
        animator = GetComponent<Animator>(); //intialises the animator variable to the animator component that is attached to gameobject
        rB = GetComponent<Rigidbody>();
        rB.freezeRotation = true; // this will halt and freeze the rotation of the rigidbody 

        resetJump(); //this is called to initialise player before moment of jumping
        //Cursor.lockState = CursorLockMode.Locked;
        //Cursor.visible = false;
    }

    private void FixedUpdate()
    { //is called to handle for physics components of gameplay
        MovePlayer();//is called to process/handle player movement
    }

    // Update is called once per frame
    void Update()
    {
        //checking if user is in touching distance/appropriate distance to be considered to be on ground level
        grounded = Physics.Raycast(transform.position, Vector3.down, playerHeight * 0.5f + 0.2f, whatIsGround);


        MyInput(); //is called to handle/process the players movement
        SpeedControl(); //is called to deploy a max speed

        if (grounded) //the drag that the rgidbody is subject to is adjusted according to if its grounded or not
            rB.drag = groundedDrag;
        else
            rB.drag = 0;

        // Set the "isMoving" parameter in the animator based on player's movement


        if (horizontalInput != 0f || verticalInput != 0f)
        { //updating the ismoving parameter dependent on if there is vertical/horizontal input detected
            animator.SetBool("isMoving", true);
            
        }
        else
        {
            animator.SetBool("isMoving", false);
        }


        if (!sR.flipX && horizontalInput < 0) //flips the sprite depening on where the player is facing
        {
            sR.flipX = true;

        }
        else if (sR.flipX && horizontalInput > 0)
        {
            sR.flipX = false;
        }


    }

    public void MyInput()
    { //this public method is called to handle and process the player input
        horizontalInput = Input.GetAxisRaw("Horizontal"); //W and S
        verticalInput = Input.GetAxisRaw("Vertical"); // A and D
        

        if (Input.GetKey(jumpKey) && readyToJump && grounded) // if ready to jump is true and the player is grounded
        {
            readyToJump = false; //the player is set to be not ready to jump as indicated by initialised value of false

            Jump(); //this method is called to enable for the player to be able to jump

            jumpSound.Play();//the appropriate sound is played when a player jumps

            Invoke(nameof(resetJump), jumpCooldown); // this will reset the ability for a player to jump after the completion of a cooldown period

        }
    }

    private void MovePlayer()
    { //this method is useful in handling the player movement
        // below calculates the movement direction based on user orientation and the input 
        moveDir = orientation.forward * verticalInput + orientation.right * horizontalInput;

        // adding force in the direction the user is looking in
        if (grounded)
        {
            rB.AddForce(moveDir.normalized * movespeed * 10f, ForceMode.Force);

            // Check if the player is moving and play the moveSound
            if ((horizontalInput != 0f || verticalInput != 0f) && !moveSound.isPlaying)
            {
                moveSound.Play();
            }
            else if (horizontalInput == 0f && verticalInput == 0f)
            {
                // Stop the moveSound when the player is not moving
                moveSound.Stop();
            }
        }
        else if (!grounded) //a modified force is applied to the rigidbody to move the player whilst in the air thus allowing for limited control
        {
            rB.AddForce(moveDir.normalized * movespeed * 10f * airMultiplier, ForceMode.Force);

            // Stop the moveSound when the player is not grounded
            moveSound.Stop();
        }
    }

    private void SpeedControl()
    { //this method is utilised to ensure a max speed is set and define
        Vector3 flatVel = new Vector3(rB.velocity.x, 0f, rB.velocity.z); // the players velocity on the x and y axis is obtained

        if(flatVel.magnitude > movespeed) //if condition checks to see if the player speed exceed max allowed speed
        {
            Vector3 limitedVel = flatVel.normalized * movespeed;// this constricts the player speed to align with the max speed allowed while maintaining intended direction
            rB.velocity = new Vector3(limitedVel.x, rB.velocity.y, limitedVel.z);
        }
    }

    private void Jump()
    { //this method allows for the players jumping to be handled and processed
        rB.velocity = new Vector3(rB.velocity.x, 0f, rB.velocity.z);
        rB.AddForce(transform.up * jumpForce, ForceMode.Impulse); //addding force to rb to jump with transform.up
    }

    private void resetJump()
    { //this method ensures that players are in a ready to state to jump after the cooling period has passed
        readyToJump = true;//the player is intialised to be ready to jump as shown by "true" initialisation
    }
}
